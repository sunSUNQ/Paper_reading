# Understanding and Securing Device Vulnerabilities through Automated Bug Report Analysis

> 2019 USENIX Xuan Feng  Beijing Key Laboratory of IoT Information Security Technology, IIE , CAS, China

## 摘要

近些年IoT类型的漏洞逐渐增多，还大部分都是对于已经披露的漏洞进行再次利用的问题， 但是，尚不清楚物联网设备漏洞普遍性的根本原因及其安全隐患，为了发现这个问题，我们**从蜜罐中收集的大量真实攻击痕迹，从黑市购买的攻击工具以及从影响较广的IoT攻击中收集的信息进行了全面的研究**。我们的研究证明了两件事情：**持续的网络攻击在很大程度上依赖于已知的漏洞以及通过其报告发布的攻击代码； 另一方面，这种对已知漏洞的依赖实际上可以用来抵御攻击者**。既然攻击者使用已披露的大量相似报告来提取漏洞模式，那么我们也可以利用这种方法来提取漏洞模式，并对系统进行保护。

自动收集分散在网络上的bug报告（博客、论坛、邮件列表等），提取了大概7500多个安全报告（涵盖12286个安全性的IoT漏洞）。

证明：可以通过基于NLP对报告进行自动分析，并生成签名，这些签名可以被防火墙和入侵检测系统使用，用来进一步缓解IoT设备攻击带来的威胁。

## 介绍

IoT设备的漏洞很多，最近越来越收到关注，今年多个论文工作都是基于已经披露的漏洞，但是仍能造成很大的影响，主要研究目的想解决这个问题。首先通过蜜罐搜集真实的攻击程序的利用漏洞情况，在所有的81个漏洞中，78个是我们搜集到的已经披露的漏洞，然后再黑市买到的四款攻击工具中，发现其中至少有34个漏洞的利用，然后全部都在我们搜集的漏洞列表以内。我们搜集到的报告中有80%的都带有相应的攻击方法。

本文提供了IoTShield，可以自动的从多种源列表获取到我们关注的IoT设备相关的报告，从过去20年的430,000个报告中发现了7,500个IoT报告。然后IoTShield自动的通过关键字提取漏洞特征信息，这些特征信息可以使入侵检测系统（IDS）或Web应用程序防火墙（WAF）可以使用它来筛选受保护的IoT设备收到的流量。

我们验证了IoTShield在蜜罐中捕获的178,778条痕迹以及八种真实设备（包括攻击和合法流量）的11,602条痕迹的功效。 此外，我们还评估了IoTShield在工业控制系统的人机界面（HMI an industrial control system’s human machine interface）Honeypot中捕获的长时间（超过一年）流量中的有效性。 评估结果表明，IoTShield可以实现高精度（97％以上）和非常低的误报率，并且对性能的影响很小。

## 主要贡献

- 利用从流行的攻击工具还有攻击事件利用蜜罐搜集到的真实数据，攻击者主要利用的是已经披露的漏洞还有已经发布的攻击代码。
- 提供的方法，利用大量已知漏洞来生成的签名，直接部署到防火墙或者入侵防护系统上可以有效的避免类似的攻击，简单，低成本，有效的防护措施可以大大提高攻击者的门槛。

## 背景

- bug life cycle 问题，修补不及时，更新不及时。
- 对入侵检测可以分成基于模式以及基于异常的检测，本文主要做的是基于模式的检测，基于模式的检测通常是人工的根据攻击行为来提取模式，但是我们发现，基于大量的足够的信息，可以使用NLP自动的构建模式。
- NLP技术：分析各种漏洞报告的文本内容。 
  - 拼写检查：用于过滤掉与IoT不相关的文档。 
  - 基于正则表达式的模式匹配：识别与IoT相关的漏洞报告。 
  - 语义一致性分析：用于检查提取的IoT实体。 
  - 语法依赖解析器：为了生成特定于漏洞的签名，需要深入了解漏洞的语义，语法解析器可以提供句子中单词之间的语法关系表示。
- 考虑一个攻击者试图利用漏洞报告中披露的安全漏洞来远程破坏IoT设备。特别是，我们专注于网络连接的IoT设备（例如IP摄像机，路由器和打印机）暴露在Internet上的攻击面。

## 蜜罐保存真实攻击信息，使用常用攻击工具进行攻击。

1. 真实设备蜜罐。

   选取了8款常用的比较典型的设备，以及其匹配的漏洞信息。

   <img src="image\image-20191203152938960.png" alt="image-20191203152938960" style="zoom:50%;" />

   设计了蜜罐部署的结构。（具体不做介绍）

   <img src="image\image-20191203153202232.png" alt="image-20191203153202232" style="zoom:50%;" />

2. 模拟蜜罐

   <img src="image\image-20191203154012348.png" alt="image-20191203154012348" style="zoom:50%;" />

3. 分析

   从2018年5月到7月，蜜罐系统收集了从47,089个IP地址传来的190,380个HTTP请求，涵盖17个国家。

   这些流量跟踪进行分析：首先，删除那些被确认为合法的流量，包括合法的登录尝试，诸如“ GET /”之类的请求以及其他普通的HTTP GET请求； 然后，通过在漏洞数据集中搜索漏洞利用代码并进一步查找常见的攻击流量模式，SQL命令的存在和各种执行命令（例如，“ cmd = / usr / bin/ telnetd”）。 我们发现了来自60个不同国家的近2,000次IoT利用尝试，平均每天有38次攻击。

   表3给出了详细的结果：对于真实的设备蜜罐，捕获了141种具有26种不同脚本的独特攻击，并从我们的模拟蜜罐中通过81种攻击脚本发现了1,860种独特攻击。 仍然无法确认约164个未知请求是合法或恶意的。

   <img src="image\image-20191203163317230.png" alt="image-20191203163317230" style="zoom:50%;" />

   通过分析这些攻击（共计2,001次），我们发现其中约有320种针对蜜罐（真实或模拟）设备，而约1,681种针对那些类型不属于任何蜜罐的设备。 一方面，这表明对手可能在没有先识别设备类型的情况下盲目进行攻击。 另一方面，这意味着我们的蜜罐具有广泛的攻击范围，不受蜜罐中部署的设备类型的限制。 更重要的是，我们的蜜罐仅观察到164个未知请求。 换句话说，超过90％的恶意攻击利用了已知的漏洞。 这一观察结果与我们对地下攻击工具包的分析一致。

   最常利用的漏洞：未经身份验证的命令注入和信息泄露。 通过向易受攻击的设备发送简单的HTTP请求以获得对设备的完全控制，可以轻松地攻击这些缺陷。 96％的IoT攻击使用我们收集的漏洞报告中包含的相同或相似脚本。 

4. 为了验证发现，进一步分析了四个地下攻击工具包和六个记录良好的物联网僵尸网络。

   地下攻击工具。 在这项工作中，我们通过使用与攻击工具包相关的一组关键字，搜索了大众化的地下市场（例如openbazaar和dream market），以试图找到发布出售此类工具的帖子。 发现帖子后，我们与卖家联系并购买了工具。 我们总共获得了四个这样的工具及其源代码，包括Brickerbot。

   <img src="image\image-20191203164101278.png" alt="image-20191203164101278" style="zoom:50%;" />

   通过分析代码，再次发现他们利用的所有漏洞都是已知的，并且他们的攻击脚本都是从漏洞报告中复制的，并且进行了较小的更改。更具体地说，从这些工具中，我们确定了与34个漏洞相关的99个不同的攻击脚本。这些漏洞都记录在我们的数据集中。在这99个攻击脚本中，其中三个与所描述的完全相同，而其余96个都稍有变化。这证实了通过分析蜜罐数据观察到的结果：大多数IoT攻击利用已知的漏洞，甚至利用漏洞报告中提供的攻击代码，另一方面，可以利用这些漏洞可以有效的抑制这种攻击浪潮。

   已知攻击。 最后分析了最近报告的一些众所周知的IoT僵尸网络，以了解是否确实使用了大多数已知的漏洞和文档化攻击脚本。 这些僵尸网络都是针对许多不同产品（例如IoT Reaper）或广泛部署在Internet上（例如Masuta）的安全漏洞的。 其中一些也关注没有补丁的漏洞。

   <img src="image\image-20191203164445221.png" alt="image-20191203164445221" style="zoom:50%;" />

   再次，我们发现在这些攻击中利用的所有漏洞也包含在我们研究中收集的报告中，并且所有攻击这些漏洞的脚本都是报告中代码的副本或变体。

## 自动化提取漏洞特征

因为IoT漏洞报告中通常会包含利用代码，所以也是这类漏洞爆发的原因之一，IoTShield通过自动化的获取信息并提取漏洞特征，来生成特征匹配，方便放进入侵检测工具以及防火墙中来防范攻击。

问题1：漏洞报告数据源多，格式不固定，如何区分IoT和others很不容易。

问题2：因为是用自然语言来描述漏洞，因此需要进行语义识别

问题3：识别特征需要特定领域的知识，以仔细区分漏洞利用的特征和漏洞的特征

为了应对这些挑战，在IoTShield中，使用**IoT漏洞提取程序**来删除不相关的内容并识别IoT安全漏洞的关键信息。 收集IoT漏洞报告后，从漏洞报告中提取漏洞描述和其他结构化信息（例如攻击脚本）的语义。 此处的描述提供了有关可以利用漏洞的所有情况的信息（例如，所有相关的参数和位置），这使我们能够利用从攻击脚本观察到的攻击面或其他结构信息（如流量日志）来利用漏洞。 问题是某些漏洞报告没有漏洞描述或结构化信息。 稍后我们讨论如何处理此问题（请参见第4.3节）。

### 框架：

<img src="image\image-20191204101519928.png" alt="image-20191204101519928" style="zoom:80%;" />

- 数据收集：用于从网络收集漏洞报告。
- IoT漏洞提取用于从大量文档（包括论坛，博客和邮件列表）中提取IoT漏洞信息。更具体地说，抓取了主流的在线资源以进行错误披露，并进一步运行了语料库质量分析器以筛选出与漏洞报告无关的文档。对于其余文档，我们使用识别器来识别IoT漏洞报告并提取关键信息，例如其类型，受影响的产品，CVE编号，作者和发布日期。该信息将用作后续签名生成阶段的描述。
- 一旦获得一组IoT漏洞报告，IoTShield首先会聚在一起描述同一漏洞的报告，然后利用NLP从描述中发现漏洞语义（例如漏洞类型，位置和参数）。然后，它提取结构化信息（例如流量日志，脚本和Linux命令）以创建漏洞利用（或PoC）模板并查找非法参数（例如用于注入命令的参数）。 之后，签名生成组件利用漏洞位置和参数来识别所有相关的攻击面，这有助于确定模板的所有参数，这些参数也可能导致漏洞利用。
  参数和模板在这里构成签名。 最后，IoTShield自动将签名转换为现有IDS或WAF中使用的格式（我们研究中构建的原型输出Snort签名[37]），以便快速部署。

### 数据集：

在表6中列出的漏洞报告网站上运行了搜寻器，包括论坛（seclist.org/fulldisclosure），邮件列表（seclist.org/bugtraq），个人博客/建议（pierrekim.github.io），研究团队咨询（coresecurity.com）漏洞存档网站（packetstromsecurity.com）。 这些来源是**从CVE中包含的外部参考文献中收集**的，从中选择了最常用的参考文献。 进一步手动选择了与IoT漏洞相关的，例如seclist.org，并将它们添加到列表中，该列表还包括一些已知的报告安全漏洞的研究组网站。

<img src="image\image-20191204102531758.png" alt="image-20191204102531758" style="zoom:50%;" />

### preprocessor

人工的分析了13种来源的结构，并写爬虫爬取。

### Corpora quality analyzer

The percentage of dictionary words：删除了内容大部分包含（超过82％）词典单词的文档，因为真实的漏洞报告包含大量的非文本信息，例如易受攻击的路径以及功能，PoC或脚本等。文本看起来更像调查文章，白皮书或通知。

The number of hyperlinks：漏洞报告（尤其是针对物联网的漏洞报告）不应包含过多的超链接。 否则，它可能是所披露所有漏洞的摘要，而不是包含详细漏洞信息的特定报告。 因此，丢弃了超过25个超链接的文档。

Threshold justification：以上两个基于经验的阈值（即82％和25），目的是筛选出几乎没有附带损害的大多数非IoT漏洞报告。 尝试估计错误地丢弃真实的IoT漏洞报告的可能性。 为此，随机抽样了100个被丢弃的文档，然后手动检查是否存在任何错误丢弃的案例。发现所有样本文档都与IoT漏洞报告无关。

### IoT vulnerability recognition

对于其余文档进一步运行识别器以发现IoT漏洞功能报告并提取关键信息（即设备类型，供应商名称和漏洞类型）。 漏洞信息的检索被建模为NLP的**命名实体识别**问题[52]。 首先试图确定四个与物联网漏洞相关的实体，包括设备类型，供应商，产品名称和漏洞类型，然后利用它们之间的依赖关系来确认与漏洞相关的描述。 采用了一组特定于IoT的识别技术来检索它们。

**实体识别**：为了识别这些单独的实体，利用了**基于关键字和正则表达式的匹配**。 对于设备类型，供应商名称和漏洞类型，我们使用了一组关键字。我们收集了所有常见的设备类型，包括路由器，照相机，调制解调器和打印机，并从Wikipedia中找到供应商名称。还收集了CWE漏洞类型。 在列表中添加了这些漏洞的通用缩写，例如CSRF和RCE。 对于产品名称和版本，由于数量庞大且难以枚举，构建了正则表达式来标识每个实体。 

<img src="image\image-20191204112652037.png" alt="image-20191204112652037" style="zoom:50%;" />

通过这种方式，可以识别所有与物联网漏洞相关的文档。 但是鉴于此类实体的普遍性，仅使用它们可能会带来大量误报。 为了解决此问题，我们利用了这些实体之间的依赖性来确保正确识别这些漏洞。

**实体间关系关联**：当这些实体确实用于描述IoT漏洞时并不是独立的。意味着它们之间存在依赖性。 特别是，供应商实体的术语在产品实体或设备类型实体之前。 另外，文档需要包含漏洞类型。 使用这些规则，我们可以将这些实体拼凑在一起，从而将IoT产品链接到漏洞。但是，仍然存在误报。

**实体检查器筛选**： 在Google中搜索提取的实体（例如D-Link DIR-600），然后计算提取的实体与搜索结果标题之间的余弦相似度。 如果相似度极低（例如0.08），我们将提取的实体视为非IoT设备。

<img src="image\image-20191204113920668.png" alt="image-20191204113920668" style="zoom:50%;" />

图3显示了漏洞报告中的IoT漏洞和其他漏洞的示例。从预处理阶段，使用关键字匹配来标识设备类型（红色），供应商（蓝色）和漏洞类型（绿色）。然后使用基于正则表达式的匹配来提取产品信息（灰色）。之后通过本地依赖项和实体检查器检查提取的实体是否组合在一起以呈现IoT漏洞概念（灰色）。

## 自动化防御生成

将上一步收集到的实体信息关系等进行分类，针对每一种漏洞进行分类，然后将每一个分类下的报告中提取漏洞语义信息以及其他结构化信息，进一步生成漏洞特征来用于防御措施。

<img src="image\image-20191204144929615.png" alt="image-20191204144929615" style="zoom:50%;" />

下图提供了一个示例，如何从IoT漏洞报告中生成特征。左上方是漏洞描述。左下方是结构化信息内容，该信息是利用此漏洞的流量日志。 IoTShield首先在描述中找到漏洞语义。 例如，command injection in PwdGrp.cgi指示漏洞类型为“命令注入”，受影响的位置为“ PwdGrp.cgi”，以及另一句话“the username, password, and group parameters”中的易受攻击的参数。 然后，IoTShield解析结构化信息，发现易受攻击的CGI的路径“ /cgibin/supervisor/PwdGrp.cgi”和用于命令注入的参数“pwd = reboot; ”，命令指示符“;”和合法配合命令列表。

可以推断出，user和grp可能也存在注入问题，但是action和lifetime参数没有。 这样，我们可以为注入漏洞构建特定于漏洞的特征，然后将其转换为Snort格式（基于漏洞类型）。

<img src="image\image-20191204145233696.png" alt="image-20191204145233696" style="zoom:60%;" />

### Report clustering

有许多不同的博客描述了相同的漏洞，并且这些报告可能从不同的方面描述该漏洞。 因此需要在规则生成阶段之前将这些报告集中在一起，以形成完整的漏洞报告。 挑战在于，尽管两个报告描述的漏洞相同，但是它们可能具有不同的格式和不同的哈希值。 我们的解决方案是使用从IoT漏洞报告中识别的实体（即设备类型，供应商，产品名称和漏洞类型）将描述同一IoT漏洞的报告进行聚集。聚集旨在补充漏洞报告的缺失信息。具有相同设备类型，供应商，产品名称和漏洞类型的漏洞很少存在。

### Semantic and structured information retrieval

首先利用NLP技术分析漏洞描述，以找到漏洞语义，包括漏洞类型，位置和带有利用参数的短句。方法是基于观察到的感兴趣的语义信息是通过相对稳定的语法表示的结构体。具体，利用漏洞类型列表来确定所记录问题的类型，并使用正则表达式来查找漏洞位置，该位置应为Web内容文件，例如“ .htm”，“.cgi”，“.php”，“.asp”和“ .html”。对于漏洞参数，方法是查找包含关键字“parameter”, “variable”, “action”, or “function”的句子，并利用这些词与参数值之间的语法关系来查找它们。为此使用Stanford Dependency Parser [51]构造了一个依赖树来解析整个句子，然后提取名词作为目标词来检查它们与关键字的关系。如果这些术语与关键字具有非“ nmod”关系3或与已标识的参数具有“ conj”关系4，则将它们视为参数。一个示例如图6所示。

<img src="image\image-20191204151837336.png" alt="image-20191204151837336" style="zoom:50%;" />

我们使用正则表达式来定位不同类型的结构化信息，包括使用Linux命令（curl和wget）的PoC，PoC URL，PoC HTML脚本和PoC流量日志， 对于每种类型的结构化信息，我们构建了一个解析器以将其转换为通用模板：

<img src="image\image-20191204152014264.png" alt="image-20191204152014264" style="zoom:50%;" />

其中HOST是设备的IP地址，端口是应用程序层服务器端口（默认为80），file.suffix是漏洞位置，而{parameters}是键值格式，其中包括用于漏洞文件的参数。 对于{parameters}中的每个项目，IoTShield都会检查它是否携带任何非法值。通过这种方式，我们的方法从漏洞报告中获取了语义和结构化信息。

### Signature generation

IoTShield利用报告中提取的信息来构建特征。具体来说，我们首先比较了漏洞的位置（从描述中恢复）和模板中的“ file.suffix”（根据结构化信息）；如果匹配认为语义信息（包括漏洞类型和参数）将与模板（例如，脚本攻击的）所建模的缺陷有关。然后根据漏洞类型，决定是否忽略模板的参数部分，因为某些漏洞不需要利用参数。就我们数据中的所有漏洞类型而言，信息泄露和目录遍历是仅两个典型的不需要参数即可利用的漏洞类型。

这种简单的签名生成过程的问题是**语义信息和结构化信息并不总是以精确的方式匹配**。 例如，在图5中，漏洞描述中的漏洞参数以自然语言（即用户名，密码和组）表示，而在结构化信息（即user，pwd和grp）中则缩写。 为了解决此问题，我们手动收集了一个列表，该列表将各个关键字映射到Linux中使用的相应缩写，例如grp for group，以翻译自然语言术语。另一个问题是，**某些漏洞报告未同时包含漏洞描述和结构化信息**。

*Vulnerability description only*：没有结构化信息，我们所能获得的仅仅是漏洞类型，位置和参数。 但是，由于参数的缩写，因此其可靠性可能会降低。 因此只能仅凭漏洞位置的知识（例如“ PwdGrp.cgi”）来生成特征。包括信息泄露和目录遍历。

*Structured information only*：如果没有漏洞描述将无法生成通用的特定于漏洞的特征。 但是仍然可以利用结构化信息来构建特定于利用程序的特征。一旦从攻击脚本中恢复的参数被发现包含Linux命令，我们可以将攻击中常用的其他命令添加到以下参数列表中： 签名生成。

## 实施与部署

原型系统建立在三个关键功能组件的基础上：报告搜寻器，漏洞检测器和规则生成器。

报告搜寻器：爬虫，wget或者scrapy。

漏洞提取器：python实现，beautiful soup框架提取页面信息，NLTK用来拆分句子，Aho–Corasick字符串搜索算法，加快实体识别。scikit-learn 用于在实体检查中计算TF-IDF（术语频率-逆文档频率）余弦相似度。

规则生成器：python实现，simhash算法来检测重复，stanford依赖解析来建立依赖树。

IoTShield可以采用两种模式进行部署：粗粒度和细粒度。

在粗粒度模式下，无论设备类型如何，所有生成的规则都将在IDS系统中使用，所有规则都将用于检查网络流量。此模式易于部署，但可能会有误报，因为某些规则可能是特定于设备的。另外，在粗粒度模式下，我们建议不要仅使用描述生成的规则。这是因为当忽略设备类型时，仅根据描述生成的规则可能会导致误报。

在细粒度模式下，我们会考虑网络环境并为给定设备类型部署规则。IoTShield首先分析网络流量或主动探测网络以识别设备类型（例如型号和品牌）及其IP地址。该步骤可以通过使用被监视网络中的设备列表或使用中提出的设备指纹识别方法来实现。此后，根据网络中当前的设备类型，将进行特征选择过程以选择相应的特征进行部署。

## 实验

随机提取了一部分报告并人工分析了，然后使用两种不同的标准来评估。

**Vulnerability extractor**：漏洞提取器。 我们从确定的报告中随机抽取了200份报告进行手动验证，并达到了94％的准确性。 总共从43万篇文章中收集了7,514个IoT漏洞报告。 这些报告披露了12,286个IoT漏洞。 图7显示了1998年至2018年每月平均披露的IoT漏洞数量。我们可以看到，自1998年以来，披露的数量有所增加，这种增加的趋势自2012年以来进一步加快，而自2014年以来有所放缓，但是 2018年达到峰值，当时每月披露约90个IoT漏洞。 

<img src="image\image-20191204170139497.png" alt="image-20191204170139497" style="zoom:50%;" />



这些物联网漏洞与设备类型和供应商有关。发现将近60％的漏洞设备来自安全漏洞最多的前10个供应商。表8列出了这10种设备类型和供应商的漏洞分布。正如我们在此处看到的那样，被认为是最常见的物联网设备的路由器，交换机和摄像设备。此外，造成漏洞最多的供应商都享有盛誉，并且拥有最大的市场份额。

<img src="image\image-20191204170332394.png" alt="image-20191204170332394" style="zoom:50%;" />

表9进一步列出了我们数据集中的十大漏洞类型。它们中的大多数是可远程利用的（例如，缓冲区溢出，拒绝服务，CSRF命令注入和身份验证绕过），可轻松用于构成IoT设备。此外，IoT恶意软件通常使用跨站点脚本（XSS），命令注入和命令执行来在受感染设备作为僵尸网络节点上执行命令。

<img src="image\image-20191204170357081.png" alt="image-20191204170357081" style="zoom:50%;" />

**Rule generation effectiveness**：规则生成有效性。 我们首先使用配备2.6GHz Intel Core i7和16GB内存的Macbook Pro，根据从IoT设备和蜜罐收集的190K HTTP请求评估了IoTShield。  HTTP请求包括从真实设备蜜罐中收集的请求以及从模拟器中收集的HTTP请求。 在我们的实验中，我们按照第3.1节中的描述标记了IoT设备流量，这些跟踪记录包括模拟器收到的178,778个HTTP请求，这些请求与26个独特的攻击脚本生成的141次攻击活动有关，其余为良性流量。 如第3.1节所述，来自真实设备的蜜罐，其中包括由81个独特的攻击脚本生成的1,860个攻击中的11,602个HTTP请求。

使用精度，召回率和误报率（FPR）评估了IoTShield的有效性。 精度定义为| TP | / | FP + TP |，召回率是| TP | / | TP + FN |，FPR是| FP | / | FP + TN |，其中TP是真实的正数， FN是false negative数，FP是误报数，TN是漏报数。表10给出了实验结果。 在模拟器收到的跟踪结果中，我们自动生成的签名的精度为98％，召回率为93％，FPR为0.06％。 在从真实设备收集的请求中，我们的签名可以实现97％的精度，83％的召回率和0.01％的FPR。

<img src="image\image-20191204172515563.png" alt="image-20191204172515563" style="zoom:50%;" />

使用了在工业试用控制系统的HMI蜜罐中捕获的长时间流量来评估IoTSheild。 HMI蜜罐用于通过盲目扫描和攻击来监视攻击流量。 持续时间为2017年10月至2018年11月，横跨七个不同城市。 通过重放流量，IoTShield报告了7,396条有关使用HMI系统的警报。 通过**手动**检查7,396条警报，我们确认大约6,705条警报确实是物联网攻击。 其余警报已确认已解决常见Web服务器上的其他漏洞。 

### 表现

**Signature generation**：为了了解IoT Shield的性能，进行了实验以衡量每个阶段处理漏洞报告的时间成本：数据收集，IoT漏洞提取和自动规则生成。 IoTShield原型可在商用台式计算机（Ubuntu 18.04、8GB内存，64位OS，具有4核Intel®Core™i7-4790 CPU @ 3.60GHz）上运行，CPU和可以轻松满足IoTShield的内存要求。 IoTShield进程在单个线程中运行。表11列出了生成一个规则的IoTShield每个阶段的平均时间成本。从Internet上获取报告的时间为0.386秒（51％）。此阶段需要消息传输，并且时间成本取决于网络条件。物联网漏洞提取需要0.154秒（21％），而规则生成会花费更多的时间0.21秒（28％），这是因为它需要使用漏洞参数建立句子的依赖关系树。总体而言，用于自动规则生成的IoTShield的时间成本在实践中较低，我们可以通过在多个线程中运行它来进一步降低时间成本。结果表明，IoTShield**是高效的，可以轻松扩展到理想水平，以通过及时更新防御规则来在线处理大量漏洞**。

<img src="image\image-20191204190634657.png" alt="image-20191204190634657" style="zoom:50%;" />

**Rule inspection**：为了在实践中评估IoT Shield的性能，我们将其作为IDS的一个组件运行，以处理在研究机构的路由器上捕获的实际流量，该机构由100,000多个Internet设备组成。 流量约为53G，此流量收集的持续时间约为2小时。 无论有没有IoTShield，我们都会播放到Snort的流量。 对于没有IoTShield的Snort，检查所有收集到的数据包需要426.28秒。 对于使用IoTShield的Snort，它仅需0.13秒即可对整个53G数据进行规则检查，这**表明IoTShield几乎不会给IDS带来用于在线数据处理的开销。**

## 总结

为了了解网络犯罪分子如何发起与物联网相关的攻击，我们利用蜜罐收集了现实世界中物联网漏洞的踪迹，并分析了四种流行的攻击工具包。我们的研究揭示了近年来IoT攻击普遍存在的一个被忽视的原因：IoT漏洞是公开可用且易于利用的，而今天的IoT攻击几乎仅使用已知漏洞来发动恶意攻击。更重要的是，我们的发现导致了IoTShield的设计，这是一个简单而有效的针对入侵检测的IoT漏洞特定签名生成系统.IoTShield最初收集了过去20年的430,000漏洞报告，并识别了7,500 IoT漏洞报告的内容。然后，IoTShield检索关键知识以生成特定于漏洞的签名。这些签名可以轻松部署在现有入侵检测系统或Web应用程序防火墙上，以检测目标IoT设备上的利用尝试。因此，IoTShield大大提高了未来物联网攻击成功的门槛。